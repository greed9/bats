#!/usr/bin/env python

##################################################
# Don't forget to start the pigpiod daemon first!
##################################################

import pigpio
import queue
import time
# 
# Initialize and keep track of pins we are using
#
class Pin:
    def __init__ ( self, pig ):
        # Pins for indicator/debugging outputs
        self.greenLedPin = 24 # was 23
        self.redLedPin = 23 # was 24
        self.yellowLedPin = 5
        self.blueLedPin = 25
        pig.set_mode( self.greenLedPin, pigpio.OUTPUT )
        pig.set_mode( self.redLedPin, pigpio.OUTPUT )
        pig.set_mode( self.yellowLedPin, pigpio.OUTPUT )
        pig.set_mode( self.blueLedPin, pigpio.OUTPUT )
        
        # Pins for bat detection inputs
        self.batDetect1 = 17
        self.batDetect2 = 27
        self.batDetect3 = 22
        pig.set_mode( self.batDetect1, pigpio.INPUT )
        pig.set_mode( self.batDetect2, pigpio.INPUT )
        pig.set_mode( self.batDetect3, pigpio.INPUT )
        
# Represents one grouping of clicks, as determined by a "quiet-time"
# interval between clicks.
#
# Bat Events watch for clicks generated by the Bat Detectors
#
class BatEvent:
    def __init__ ( self, pin, quiet):
        self.pin = pin
        self.quietInterval = quiet
        self.startTick = 0
        self.lastTick = 0 
        self.nClicks = 0
        self.duration = 0 
        self.state = 0
    
    def count(self, tick):
        if self.state == 0:
            self.startTick = tick
            self.lastTick = tick
            self.state = 1
            
        self.nClicks = self.nClicks + 1
        diff = pigpio.tickDiff ( self.lastTick, tick )
        self.lastTick = tick
        
        if diff > self.quietInterval:
            return True
        else:
            self.duration = self.duration + diff
            return False
    
    def restart (self, tick):
        self.startTick = tick
        self.lastTick = tick
        self.nClicks = 0
        self.duration = 0
        self.state = 0
    
# Represents one Ping HC-SR04 sensor connected to one GPIO pin
# A bat detector enqueues a set of information for each click detected
#
# That information can be handled by a BatEvent
#
class BatDetector:

    """Class to handle pulses from a single bat detector"""

    def __init__(self, pi, gpioPin, ledPin, q ):
   
        self.pi = pi
        self.gpioPin = gpioPin
        self.ledPin = ledPin
        self.q = q
        self.state = 0 
        self.lastTicks = 0

        self.pi.set_mode(gpioPin, pigpio.INPUT)

        self.pi.set_pull_up_down(gpioPin, pigpio.PUD_UP)

        self.cbA = self.pi.callback(gpioPin, pigpio.FALLING_EDGE, self._pulse)

    def _pulse(self, gpio, level, tick):

        """
        ISR -- sort of
        """

        diff = pigpio.tickDiff ( self.lastTicks, tick ) 
        self.lastTicks = tick 
        t = ( tick, gpio, diff, self.state )
        self.q.put ( t, False )
        if self.state == 0 :
            self.state = 1
        else :
            self.state = 0 
            
        # Flash as event enqueued
        self.pi.write ( self.ledPin, self.state )

    def cancel(self):

        """
        Cancel this ISR
        """

        self.cbA.cancel()
        
# Turn all the leds off
def ledsOff ( ):
    
    pi.write ( pins.greenLedPin, 0 )
    pi.write ( pins.redLedPin, 0 )
    pi.write ( pins.yellowLedPin, 0 )
    pi.write ( pins.blueLedPin, 0 )
    
if __name__ == "__main__":

    # Get a handle to PIGPIO
    pi = pigpio.pi()
    
    # Create a Pin object to initialize and ref GPIOs
    pins = Pin ( pi )
    
    # Instantiate queue to hold events from listeners
    q = queue.Queue ( )
    
    # Show off the leds
    ledsOff ( )
    time.sleep( 2 )
    pi.write( pins.redLedPin, 1)
    time.sleep( 2 )
    pi.write( pins.greenLedPin, 1)
    time.sleep( 2 )
    pi.write( pins.blueLedPin, 1)
    time.sleep( 2 )
    ledsOff ( )
    
    
    # Instantiate the listener for each detector
    #
    bat1 = BatDetector ( pi, pins.batDetect1, pins.redLedPin, q )
    bat2 = BatDetector ( pi, pins.batDetect2, pins.greenLedPin, q )
    bat3 = BatDetector ( pi, pins.batDetect3, pins.blueLedPin, q )
    
    # Create a BatEvent for each BatDetector.  Only one event
    # per BatDetector can be active at one time
    quiet = 10000
    event1 = BatEvent (pins.batDetect1, quiet)
    event2 = BatEvent (pins.batDetect2, quiet)
    event3 = BatEvent (pins.batDetect3, quiet)
    
    # Dequeue events and flash leds
    while 1:
        ( tick, gpio, diff, state ) = q.get ( )
        #print ( str( tick ) + "," + str (gpio) + "," + str(diff) + "," + str(state) )
        try :
            if gpio == pins.batDetect1 :
                # Flash as event dequeued
                pi.write ( pins.greenLedPin, state )
                if event1.count(tick) == True:
                    print ( str(event1.pin) + "," + str(event1.nClicks) + "," + str(event1.duration))
                    event1.restart(tick)
                
            elif gpio == pins.batDetect2 :
                # Flash as event dequeued
                pi.write ( pins.redLedPin, state )
                if event2.count(tick) == True:
                    print ( str(event2.pin) + "," + str(event2.nClicks) + "," + str(event2.duration))
                    event2.restart(tick)
                
            else:
                # Flash as event dequeued
                pi.write ( pins.yellowLedPin, state )
                if event3.count(tick) == True:
                    print ( str(event3.pin) + "," + str(event3.nClicks) + "," + str(event3.duration))
                    event3.restart(tick)
        except OSError :
            pass
        
    time.sleep(30)

    # Clean up by removing pin listeners
    bat1.cancel ( )
    bat2.cancel ( )
    bat3.cancel ( )

     # Turn all the leds off
    pi.write ( pins.greenLedPin, 0 )
    pi.write ( pins.redLedPin, 0 )
    pi.write ( pins.yellowLedPin, 0 )
    pi.write ( pins.blueLedPin, 0 )
    
    pi.stop()

